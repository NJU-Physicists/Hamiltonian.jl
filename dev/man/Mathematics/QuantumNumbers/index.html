<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum numbers · QuantumLattices.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Mathematics/QuantumNumbers/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QuantumLattices.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Unitcell Description</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/">Spatial info of a unitcell</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/InternalDegreesOfFreedom/">Internal degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Engine App Interface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/EngineAppInterface/Introduction/">Introduction</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Prerequisites</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Prerequisites/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../Prerequisites/TypeTraits/">Type traits</a></li><li><a class="tocitem" href="../../Prerequisites/Factories/">Factories</a></li><li><a class="tocitem" href="../../Prerequisites/CompositeStructures/">Composite structures</a></li><li><a class="tocitem" href="../../Prerequisites/SimpleTrees/">Simple trees</a></li><li><a class="tocitem" href="../../Prerequisites/NamedVectors/">Named vectors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Mathematics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li><a class="tocitem" href="../Combinatorics/">Combinatorics</a></li><li><a class="tocitem" href="../VectorSpaces/">Vector spaces</a></li><li><a class="tocitem" href="../AlgebraOverFields/">Algebra over fields</a></li><li class="is-active"><a class="tocitem" href>Quantum numbers</a><ul class="internal"><li><a class="tocitem" href="#AbelianNumber"><span>AbelianNumber</span></a></li><li><a class="tocitem" href="#AbelianNumbers"><span>AbelianNumbers</span></a></li><li><a class="tocitem" href="#qnmanual"><span>Manual</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Essentials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Essentials/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../Essentials/Spatials/">Spatials</a></li><li><a class="tocitem" href="../../Essentials/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../../Essentials/Terms/">Terms</a></li><li><a class="tocitem" href="../../Essentials/FockPackage/">Fock package</a></li><li><a class="tocitem" href="../../Essentials/SpinPackage/">Spin package</a></li><li><a class="tocitem" href="../../Essentials/Frameworks/">Frameworks</a></li></ul></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../../developer/CodeStyle/">Code style guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Mathematics</a></li><li class="is-active"><a href>Quantum numbers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantum numbers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/man/Mathematics/QuantumNumbers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantum-numbers"><a class="docs-heading-anchor" href="#Quantum-numbers">Quantum numbers</a><a id="Quantum-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-numbers" title="Permalink"></a></h1><p>Quantum numbers can be considered as the conserved labels for the bases of a Hilbert space when a quantum system hosts some symmetries. Here we only implement Abelian quantum numbers because non-Abelian ones are far more complicated yet much less used. In practice, quantum numbers can be integers or half integers, therefore, we use real numbers to denote them in this module for simplicity. Independent quantum numbers, such as the particle number and the spin z-component, can coexist at the same time. We use type <a href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>AbelianNumber</code></a> to represent the complete set of independent ones for a single basis of a Hilbert space, and type <a href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers"><code>AbelianNumbers</code></a> to represent the whole quantum numbers for the total bases.</p><h2 id="AbelianNumber"><a class="docs-heading-anchor" href="#AbelianNumber">AbelianNumber</a><a id="AbelianNumber-1"></a><a class="docs-heading-anchor-permalink" href="#AbelianNumber" title="Permalink"></a></h2><p>The abstract type for the complete set of independent quantum numbers for a single basis.</p><p>Main features include:</p><ul><li>function <code>fieldnames</code>: get the names of the quantum numbers</li><li>function <code>periods</code>: get the periods of the quantum numbers</li><li>arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, <code>⊕</code>, <code>⊗</code></li><li>hashable: concrete instances can be used as keys for a dict or a set</li><li>iterable: concrete instances are iterable over their values</li><li>comparable: two concrete instances can be compared</li></ul><p>In particular, <code>AbelianNumber &lt;: HomoNamedVector{Float}</code>, all features supported by <code>HomoNamedVector</code> are also available for <code>HomoNamedVector</code>. See also <a href="../../Prerequisites/NamedVectors/#HomoNamedVector">HomoNamedVector</a>.</p><p>For convenience, <strong>4</strong> kinds of quantum numbers are predefined in this module, i.e.</p><ul><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.SQN"><code>SQN</code></a>: for spin z-component reserved systems</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.PQN"><code>PQN</code></a>: for particle number reserved systems</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.SPQN"><code>SPQN</code></a>: for both particle number and spin-z component reserved systems</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.Z2QN"><code>Z2QN</code></a>: for systems with a <span>$Z_2$</span> conservation quantum number</li></ul><p>Users who want to define their own <span>$Z_N$</span>-like quantum numbers must handle the periodicities in the construction function, otherwise, wrong results will be get when arithmetic operations, such as <code>+</code> or <code>-</code>, are involved. It is highly recommended to use the macro <a href="#QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber-Tuple{Any,Any,Any}"><code>@abeliannumber</code></a> to define your own concrete <code>AbelianNumber</code>s.</p><h2 id="AbelianNumbers"><a class="docs-heading-anchor" href="#AbelianNumbers">AbelianNumbers</a><a id="AbelianNumbers-1"></a><a class="docs-heading-anchor-permalink" href="#AbelianNumbers" title="Permalink"></a></h2><p>The whole quantum numbers for the total bases.</p><p>By design, a <a href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers"><code>AbelianNumbers{QN}</code></a> has one type parameter:</p><ul><li><code>QN&lt;:AbelianNumber</code>: the type of the quantum numbers contained in it</li></ul><p>And 3 attributes:</p><ul><li><code>form::Char</code>: Its form, whose value must be one of the followings<ul><li><code>&#39;G&#39;</code>: the general form, which has no restriction for its <code>contents</code></li><li><code>&#39;U&#39;</code>: the unitary form, which requires no duplicates in its <code>contents</code></li><li><code>&#39;C&#39;</code>: the canonical form, which requires both no duplicates and ascending-order in its <code>contents</code></li></ul>Usually, G-formed and U-formed <code>AbelianNumbers</code>es can be transformed to the corresponding C-formed ones by the <a href="#Base.sort-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>sort</code></a> function.</li><li><code>contents::Vector{QN}</code>: The quantum numbers contained in it. To achieve high efficiency, it is required to be an homogenous array of a certain kind of concrete <code>AbelianNumber</code>.</li><li><code>indptr::Vector{Int}</code>: The indptr of the quantum numbers contained in it, which is similar to the <code>colptr</code> attribute of a <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/#man-csc-1">CSC sparse matrix</a> and records the compression info of its <code>contents</code>.</li></ul><p>Main features include:</p><ul><li>function <code>eltype</code>: get the concrete type of the quantum numbers it contains</li><li>index access: get the contents directly by the <code>getindex</code> function</li><li>arithmetic operations: <code>+</code>, <code>-</code>, <code>*</code>, <code>^</code>, <code>⊗</code>, <code>⊕</code></li><li>iterable: various iteration supports, including functions such as <code>iterate</code>, <code>keys</code>, <code>values</code> and <code>pairs</code></li></ul><p>For a complete summation of its features, please refer to the <a href="#qnmanual">manual</a>.</p><p>For convenience, <strong>5</strong> functions are predefined to generate the <code>AbelianNumbers</code> of common physical systems, i.e.</p><ul><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.SQNS-Tuple{Real}"><code>SQNS</code></a>: a single spin</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.PQNS-Tuple{Real}"><code>PQNS</code></a>: a single-particle state with at most <code>N</code> identical particles</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.SzPQNS-Tuple{Real}"><code>SzPQNS</code></a>: a single-particle state with at most one particle whose spin-z component is <code>Sz</code></li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.SPQNS-Tuple{Real}"><code>SPQNS</code></a>: a single site with internal degrees of freedom that can be ascribed to a spin</li><li><a href="#QuantumLattices.Mathematics.QuantumNumbers.Z2QNS-Tuple{}"><code>Z2QNS</code></a>: any <span>$Z_2$</span> Hilbert space</li></ul><h2 id="qnmanual"><a class="docs-heading-anchor" href="#qnmanual">Manual</a><a id="qnmanual-1"></a><a class="docs-heading-anchor-permalink" href="#qnmanual" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qnbruteforce" href="#QuantumLattices.Mathematics.QuantumNumbers.qnbruteforce"><code>QuantumLattices.Mathematics.QuantumNumbers.qnbruteforce</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qnbruteforce</code></pre><p>Indicate that <a href="../../Interfaces/#QuantumLattices.Interfaces.decompose"><code>decompose</code></a> uses the brute force method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L668-L672">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qncompression" href="#QuantumLattices.Mathematics.QuantumNumbers.qncompression"><code>QuantumLattices.Mathematics.QuantumNumbers.qncompression</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qncompression</code></pre><p>Indicate that <a href="#Base.findall-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>findall</code></a> and <a href="../../Interfaces/#QuantumLattices.Interfaces.permute"><code>permute</code></a> use the compressed contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L371-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qncontents" href="#QuantumLattices.Mathematics.QuantumNumbers.qncontents"><code>QuantumLattices.Mathematics.QuantumNumbers.qncontents</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qncontents</code></pre><p>Indicate that <a href="../../Interfaces/#QuantumLattices.Interfaces.expand"><code>expand</code></a> uses the compressed/expanded contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L447-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qncounts" href="#QuantumLattices.Mathematics.QuantumNumbers.qncounts"><code>QuantumLattices.Mathematics.QuantumNumbers.qncounts</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qncounts</code></pre><p>Indicate that methods with <code>AbelianNumbers</code> use the count number of the compressed contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qnexpansion" href="#QuantumLattices.Mathematics.QuantumNumbers.qnexpansion"><code>QuantumLattices.Mathematics.QuantumNumbers.qnexpansion</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qnexpansion</code></pre><p>Indicate that <a href="#Base.findall-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>findall</code></a> and <a href="../../Interfaces/#QuantumLattices.Interfaces.permute"><code>permute</code></a> use the expanded contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qnindices" href="#QuantumLattices.Mathematics.QuantumNumbers.qnindices"><code>QuantumLattices.Mathematics.QuantumNumbers.qnindices</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qnindices</code></pre><p>Indicate that <a href="../../Interfaces/#QuantumLattices.Interfaces.expand"><code>expand</code></a> uses the indices of the compressed/expanded contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L453-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qnindptr" href="#QuantumLattices.Mathematics.QuantumNumbers.qnindptr"><code>QuantumLattices.Mathematics.QuantumNumbers.qnindptr</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qnindptr</code></pre><p>Indicate that methods with <code>AbelianNumbers</code> use the index pointer of the compressed contents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.qnmontecarlo" href="#QuantumLattices.Mathematics.QuantumNumbers.qnmontecarlo"><code>QuantumLattices.Mathematics.QuantumNumbers.qnmontecarlo</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">qnmontecarlo</code></pre><p>Indicate that <a href="../../Interfaces/#QuantumLattices.Interfaces.decompose"><code>decompose</code></a> uses the Monte Carlo method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L675-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type for all concrete quantum numbers for a single basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers" href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers"><code>QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbelianNumbers(form::Char, contents::Vector{&lt;:AbelianNumber}, counts::Vector{Int}, ::QNCounts)
AbelianNumbers(form::Char, contents::Vector{&lt;:AbelianNumber}, indptr::Vector{Int}, ::QNIndptr)</code></pre><p>The whole quantum numbers of the total bases of a Hilbert space.</p><p>The default constructors construct an <code>AbelianNumbers</code> from a vector of concrete quantum numbers and an vector containing their counts or indptr.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L139-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers" href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers"><code>QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbelianNumbers(qn::AbelianNumber, count::Int=1)</code></pre><p>Construct an <code>AbelianNumbers</code> with one unique quantum number which occurs <code>count</code> times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s15&quot;,var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(UnitRange{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Integer) where var&quot;#s15&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}" href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s15&quot;,var&quot;#s14&quot;} where var&quot;#s14&quot;&lt;:(UnitRange{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:Integer) where var&quot;#s15&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}"><code>QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AbelianNumbers(od::OrderedDict{&lt;:AbelianNumber, &lt;:UnitRange{&lt;:Integer}})</code></pre><p>Construct an <code>AbelianNumbers</code> from an ordered dict containing concrete quantum numbers and their slices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L185-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s17&quot;,var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:Integer where var&quot;#s17&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}" href="#QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers-Tuple{OrderedCollections.OrderedDict{var&quot;#s17&quot;,var&quot;#s15&quot;} where var&quot;#s15&quot;&lt;:Integer where var&quot;#s17&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}"><code>QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AbelianNumbers(od::OrderedDict{&lt;:AbelianNumber, &lt;:Integer})</code></pre><p>Construct an <code>AbelianNumbers</code> from an ordered dict containing concrete quantum numbers and their counts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.PQN" href="#QuantumLattices.Mathematics.QuantumNumbers.PQN"><code>QuantumLattices.Mathematics.QuantumNumbers.PQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PQN(N::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with particle number <code>N</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.SPQN" href="#QuantumLattices.Mathematics.QuantumNumbers.SPQN"><code>QuantumLattices.Mathematics.QuantumNumbers.SPQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SPQN(N::Real, Sz::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with both particle number <code>N</code> and spin z-component <code>Sz</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.SQN" href="#QuantumLattices.Mathematics.QuantumNumbers.SQN"><code>QuantumLattices.Mathematics.QuantumNumbers.SQN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SQN(Sz::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with spin z-component <code>Sz</code> conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.Z2QN" href="#QuantumLattices.Mathematics.QuantumNumbers.Z2QN"><code>QuantumLattices.Mathematics.QuantumNumbers.Z2QN</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Z2QN(N::Real)</code></pre><p>The concrete <code>AbelianNumber</code> of a quantum system with a Z₂-like conserved quantity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/697e782ab86bfcdd7fd15550241fe162c51d9f98/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber-Tuple{Any,Any,Any}" href="#QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber-Tuple{Any,Any,Any}"><code>QuantumLattices.Mathematics.QuantumNumbers.@abeliannumber</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@abeliannumber typename fieldnames fieldperiods</code></pre><p>Construct a concrete <code>AbelianNumber</code> with the type name being <code>typename</code>, fieldnames specified by <code>fieldnames</code> and periods specified by <code>fieldperiods</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,Integer}" href="#Base.:*-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">*(qn::AbelianNumber, factor::Integer) -&gt; typeof(qn)
*(factor::Integer, qn::AbelianNumber) -&gt; typeof(qn)
*(qns::AbelianNumbers, factor::Integer) -&gt; AbelianNumbers
*(factor::Integer, qns::AbelianNumbers) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>*</code> operator for the multiplication between an integer and an <code>AbelianNumber</code> or an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L525-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}" href="#Base.:+-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">+(qn::AbelianNumber) -&gt; typeof(qn)
+(qn::QN, qns::QN...) where QN&lt;:AbelianNumber -&gt; QN
+(qns::AbelianNumbers) -&gt; AbelianNumbers
+(qn::QN, qns::AbelianNumbers{QN}) where QN&lt;:AbelianNumber -&gt; AbelianNumbers{QN}
+(qns::AbelianNumbers{QN}, qn::QN) where QN&lt;:AbelianNumber -&gt; AbelianNumbers{QN}</code></pre><p>Overloaded <code>+</code> operator for <code>AbelianNumber</code> and <code>AbelianNumbers</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>The addition between an <code>AbelianNumbers</code> and an <code>AbelianNumber</code> is just a global shift of the contents of the <code>AbelianNumbers</code> by the <code>AbelianNumber</code>, therefore, the result is an <code>AbelianNumbers</code>.</li><li><code>+</code> cannot be used between two <code>AbelianNumbers</code> because the result is ambiguous. Instead, use <code>⊕</code> for direct sum and <code>⊗</code> for direct product.</li><li>To ensure type stability, two <code>AbelianNumber</code> can be added together if and only if they are of the same type.</li><li>Similarly, an <code>AbelianNumber</code> and an <code>AbelianNumbers</code> can be added together if and only if the former&#39;s type is the same with the latter&#39;s eltype.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L485-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}" href="#Base.:--Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">-(qn::AbelianNumber) -&gt; typeof(qn)
-(qn1::QN, qn2::QN) where QN&lt;:AbelianNumber -&gt; QN
-(qns::AbelianNumbers) -&gt; AbelianNumbers
-(qn::QN, qns::AbelianNumbers{QN}) where QN&lt;:AbelianNumber -&gt; AbelianNumbers{QN}
-(qns::AbelianNumbers{QN}, qn::QN) where QN&lt;:AbelianNumber -&gt; AbelianNumbers{QN}</code></pre><p>Overloaded <code>-</code> operator for <code>AbelianNumber</code> and <code>AbelianNumbers</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>The subtraction between an <code>AbelianNumbers</code> and an <code>AbelianNumber</code> is just a global shift of the contents of the <code>AbelianNumbers</code> by the <code>AbelianNumber</code>, therefore, the result is an <code>AbelianNumbers</code>.</li><li><code>-</code> cannot be used between two <code>AbelianNumbers</code> because the result is ambiguous. Instead, use <code>⊕</code> with signs for direct sum and <code>⊗</code> with signs for direct product.</li><li>To ensure type stability, an <code>AbelianNumber</code> can be subtracted by another <code>AbelianNumber</code> if and only if they are of the same type.</li><li>Similarly, an <code>AbelianNumber</code> can be subtracted by an <code>AbelianNumbers</code> or vice versa if and only if the former&#39;s type is the same with the latter&#39;s eltype.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L505-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.:==-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(qns1::AbelianNumbers, qns2::AbelianNumbers) -&gt; Bool</code></pre><p>Overloaded equivalent operator. Two <code>AbelianNumbers</code>es are equal to each other if and only if both their <code>contents</code>es and <code>indptr</code>s are elementwise equal to each other.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not necessary for two <code>AbelianNumbers</code>es to have the same eltype nor the same form to be equal to each other.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L201-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:^-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,Integer}" href="#Base.:^-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,Integer}"><code>Base.:^</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">^(qn::AbelianNumber, factor::Integer) -&gt; typeof(qn)
^(qns::AbelianNumbers, factor::Integer) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>^</code> operator for <code>AbelianNumber</code> and <code>AbelianNumbers</code>. This operation translates into the direct product of <code>factor</code> copies of <code>qn</code> or <code>qns</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L541-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eltype-Union{Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}}, Tuple{QN}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#Base.eltype-Union{Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}}, Tuple{QN}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">eltype(::Type{&lt;:AbelianNumbers{QN}}) where {QN&lt;:AbelianNumber}
eltype(qns::AbelianNumbers)</code></pre><p>Get the type of the concrete <code>AbelianNumber</code> contained in an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L242-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.filter-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#Base.filter-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN}}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>Base.filter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">filter(target::QN, qns::AbelianNumbers{QN}) where QN&lt;:AbelianNumber -&gt; AbelianNumbers{QN}
filter(targets::NTuple{N, QN}, qns::AbelianNumbers{QN}) where {N, QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Find a subset of an <code>AbelianNumbers</code> by picking out the quantum numbers in targets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L416-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.findall-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#Base.findall-Union{Tuple{QN}, Tuple{QN,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>Base.findall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findall(target::QN, qns::AbelianNumbers{QN}, ::QNCompression) where QN&lt;:AbelianNumber -&gt; Vector{Int}
findall(target::QN, qns::AbelianNumbers{QN}, ::QNExpansion) where QN&lt;:AbelianNumber -&gt; Vector{Int}
findall(targets::NTuple{N, QN}, qns::AbelianNumbers{QN}, ::QNCompression) where {N, QN&lt;:AbelianNumber} -&gt; Vector{Int}
findall(targets::NTuple{N, QN}, qns::AbelianNumbers{QN}, ::QNExpansion) where {N, QN&lt;:AbelianNumber} -&gt; Vector{Int}</code></pre><p>Find all the indices of the target quantum numbers in the contents (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qncompression"><code>qncompression</code></a> case) or the expansion (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qnexpansion"><code>qnexpansion</code></a> case) of an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L384-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Int64}" href="#Base.getindex-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getindex(qns::AbelianNumbers, index::Int) -&gt; eltype(qns)
getindex(qns::AbelianNumbers, slice::UnitRange{Int}) -&gt; AbelianNumbers
getindex(qns::AbelianNumbers, indices::Vector{Int}) -&gt; AbelianNumbers</code></pre><p>Overloaded <code>[]</code> operator.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>For an <code>AbelianNumbers</code>, all these <code>getindex</code> functions act on its <code>contents</code>, i.e. its compressed data, but not on its expansion, i.e. the uncompressed data. This definition is consistent with the <a href="../../Essentials/DegreesOfFreedom/#Base.length-Tuple{FilteredAttributes}"><code>length</code></a> function.</li><li>When the index is an integer, the result is an <code>AbelianNumber</code>, while when the index is a unit range or a vector of intgers, the result is an <code>AbelianNumbers</code>. The logic is quite reasonable because such behaviors are much alike to those of a vector container.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L251-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.isequal-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(qns1::AbelianNumbers, qns2::AbelianNumbers) -&gt; Bool</code></pre><p>Overloaded equivalent operator. Two <code>AbelianNumbers</code>es are equal to each other if and only if both their <code>contents</code>es and <code>indptr</code>s are elementwise equal to each other.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It is not necessary for two <code>AbelianNumbers</code>es to have the same eltype nor the same form to be equal to each other.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L211-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterate(qns::AbelianNumbers, state::Int=1)
iterate(rv::Iterators.Reverse{&lt;:AbelianNumbers}, state::Int=length(rv.itr, false))</code></pre><p>Iterate or reversely iterate over the concrete <code>AbelianNumber</code>s contained in an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L278-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.keys-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">keys(qns::AbelianNumbers) -&gt; Vector{qns|&gt;eltype}</code></pre><p>Iterate over the concrete <code>AbelianNumber</code>s contained in an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L287-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Union{Tuple{QN}, Tuple{Type{QN},QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#Base.kron-Union{Tuple{QN}, Tuple{Type{QN},QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kron(::Type{QN}, qn1::AbelianNumber, qn2::AbelianNumber) where QN&lt;:AbelianNumber -&gt; QN
kron(qns::Vararg{&lt;:AbelianNumber, N}; signs::NTuple{N, Int}=ntuple(i-&gt;1, Val(N))) where N -&gt; eltype(qns)
kron(qnses::Vararg{AbelianNumbers{QN}, N}; signs::NTuple{N, Int}=ntuple(i-&gt;1, Val(N))) where {N, QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Get the direct product of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Physically, the direct product of a couple of <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es are defined by the direct product of the bases of the Hilbert spaces they represent. Therefore, <code>AbelianNumbers</code> with differenct types or <code>AbelianNumbers</code>es with differenct eltypes are allowed to be direct producted in principle. However, for simplicity, we only implement a method which handle the situation of two <code>AbelianNumber</code>s with differenct types. The type of the result should be provided as the first parameter. Note that in this situation, the <code>fieldnames</code> and <code>periods</code> of the result type must be exactly equal to the flattened fieldnames and periods of the two input <code>AbelianNumber</code>s, which means, even the order of the input <code>AbelianNumber</code>s matters.</li><li>Apparently, the dimension of the result equals the product of those of the inputs. Therefore, the direct product of <code>AbelianNumber</code>s is also an <code>AbelianNumber</code> since its dimension is still one.</li><li>For other situations except the one mentioned in Note.1, the input <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es must be homogenous. Meanwhile, signs can also be provided for these situations. Note that each quantum number in the contents of the result is obtained by a summation of the corresponding quanum numbers out of the inputs with the correct signs. This is a direct observation of the Abelian nature of our quantum numbers.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L596-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.length-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(qns::AbelianNumbers) -&gt; Int</code></pre><p>Get the number of unduplicate qunatum numbers in the <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.pairs-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Union{QuantumLattices.Mathematics.QuantumNumbers.QNCounts, QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}}" href="#Base.pairs-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Union{QuantumLattices.Mathematics.QuantumNumbers.QNCounts, QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}}"><code>Base.pairs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pairs(qns::AbelianNumbers, choice::Union{QNIndptr, QNCounts})</code></pre><p>Iterate over the <code>AbelianNumber=&gt;slice</code> or <code>AbelianNumber=&gt;count</code> pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L303-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.show-Tuple{IO,QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, qns::AbelianNumbers)</code></pre><p>Show an <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L221-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.sort-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.sort-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.sort</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort(qns::AbelianNumbers) -&gt; Tuple{AbelianNumbers, Vector{Int}}</code></pre><p>Sort the quantum numbers of an <code>AbelianNumber</code>, return the sorted <code>AbelianNumber</code> and the permutation array that sorts the expansion of the original <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.string-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#Base.string-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>Base.string</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">string(qns::AbelianNumbers) -&gt; String</code></pre><p>Convert an <code>AbelianNumbers</code> to string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.union-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N}}, Tuple{N}} where N" href="#Base.union-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N}}, Tuple{N}} where N"><code>Base.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">union(qns::Vararg{&lt;:AbelianNumber, N}; signs::NTuple{N, Int}=ntuple(i-&gt;1, Val(N))) where N -&gt; AbelianNumbers
union(qnses::Vararg{AbelianNumbers{QN}, N}; signs::NTuple{N, Int}=ntuple(i-&gt;1, Val(N))) where {N, QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}</code></pre><p>Get the direct sum of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Physically, the direct sum of a couple of <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es is defined by the direct sum of the bases of the Hilbert spaces they represent. Therefore, the input <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es must be homogenous. Inhomogenous &#39;AbelianNumber&#39;s must be direct producted first to ensure homogenity before the direct sum.</li><li>Apparently, the dimension of the result equals the summation of those of the inputs, which means, even for <code>AbelianNumber</code>s, the result will be naturally an <code>AbelianNumbers</code> because the dimension of the result is larger than 1.</li><li>Signs of <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es can be provided when getting their direct sums.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L568-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.values-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}" href="#Base.values-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}"><code>Base.values</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">values(qns::AbelianNumbers, ::QNIndptr)
values(qns::AbelianNumbers, ::QNCounts)</code></pre><p>Iterate over the slices/counts of the <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.:⊕-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N} where N}" href="#QuantumLattices.Interfaces.:⊕-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N} where N}"><code>QuantumLattices.Interfaces.:⊕</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">⊕(qns::AbelianNumber...) -&gt; AbelianNumbers{qns|&gt;eltype}
⊕(qnses::AbelianNumbers...) -&gt; qnses|&gt;eltype</code></pre><p>Get the direct sum of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.:⊗-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N} where N}" href="#QuantumLattices.Interfaces.:⊗-Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber,N} where N}"><code>QuantumLattices.Interfaces.:⊗</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">⊗(qns::AbelianNumber...) -&gt; eltype(qns)
⊗(qnses::AbelianNumbers...) -&gt; eltype(qnses)</code></pre><p>Get the direct product of some <code>AbelianNumber</code>s or <code>AbelianNumbers</code>es.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L559-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.decompose-Union{Tuple{QN}, Tuple{N}, Tuple{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},N}},QN,Tuple{Vararg{Int64,N}},QuantumLattices.Mathematics.QuantumNumbers.QNBruteForce}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber where N" href="#QuantumLattices.Interfaces.decompose-Union{Tuple{QN}, Tuple{N}, Tuple{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},N}},QN,Tuple{Vararg{Int64,N}},QuantumLattices.Mathematics.QuantumNumbers.QNBruteForce}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber where N"><code>QuantumLattices.Interfaces.decompose</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decompose(qnses::NTuple{N, AbelianNumbers{QN}}, target::QN, signs::NTuple{N, Int}, ::QNBruteForce; nmax::Int=20) where {N, QN&lt;:AbelianNumber} -&gt; Vector{NTuple{N, Int}}
decompose(qnses::NTuple{N, AbelianNumbers{QN}}, target::QN, signs::NTuple{N, Int}, ::QNMonteCarlo; nmax::Int=20) where {N, QN&lt;:AbelianNumber} -&gt; Vector{NTuple{N, Int}}</code></pre><p>Find a couple of decompositions of <code>target</code> with respect to <code>qnses</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A tuple of integers <code>(i₁, i₂, ...)</code> is called a decomposition of a given <code>target</code> with respect to the given <code>qnses</code> if and only if they satisfy the &quot;decomposition rule&quot;:</p><div>\[\sum_\text{j} \text{signs}[\text{j}]\times\text{qnses}[\text{j}][\text{i}_{\text{j}}]==\text{target}\]</div><p>This equation is in fact a kind of a set of restricted <a href="https://en.wikipedia.org/wiki/Diophantine_equation#Linear_Diophantine_equations">linear Diophantine equations</a>. Indeed, our quantum numbers are always discrete Abelian ones and all instances of a concrete <code>AbelianNumber</code> forms a <a href="https://en.wikipedia.org/wiki/Module_(mathematics)">module</a> over the <a href="https://en.wikipedia.org/wiki/Ring_(mathematics)">ring</a> of integers. Therefore, each quantum number can be represented as a integral multiple of the unit element of the Abelian module, which results in the final reduction of the above equation to a set of linear Diophantine equations. Then finding a decomposition is equivalent to find a solution of the reduced linear Diophantine equations, with the restriction that the quantum numbers constructed from the solution should be in the corresponding <code>qnses</code>. Here we provide two methods to find such decompositions, one is by brute force (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qnbruteforce"><code>qnbruteforce</code></a> case), and the other is by Monte Carlo simultatioins (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qnmontecarlo"><code>qnmontecarlo</code></a> case).</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L682-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.dimension-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}" href="#QuantumLattices.Interfaces.dimension-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers}"><code>QuantumLattices.Interfaces.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimension(qns::AbelianNumbers) -&gt; Int</code></pre><p>The dimension of the Hilbert space an <code>AbelianNumbers</code> represents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L333-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.dimension-Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}" href="#QuantumLattices.Interfaces.dimension-Tuple{Type{var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber}"><code>QuantumLattices.Interfaces.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimension(::Type{&lt;:AbelianNumber}) -&gt; Int
dimension(::AbelianNumber) -&gt; Int</code></pre><p>The dimension of the Hilbert space an <code>AbelianNumber</code> represents. Apparently, this is always 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.expand-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNContents}" href="#QuantumLattices.Interfaces.expand-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNContents}"><code>QuantumLattices.Interfaces.expand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">expand(qns::AbelianNumbers, ::QNContents) -&gt; Vector{qns|&gt;eltype}
expand(qns::AbelianNumbers, ::QNIndices) -&gt; Vector{Int}</code></pre><p>Expand the contents (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qncontents"><code>qncontents</code></a> case) or indices (<a href="#QuantumLattices.Mathematics.QuantumNumbers.qnindices"><code>qnindices</code></a> case) of an <code>AbelianNumbers</code> to the uncompressed form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L460-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.permute-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Array{Int64,1},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}" href="#QuantumLattices.Interfaces.permute-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,Array{Int64,1},QuantumLattices.Mathematics.QuantumNumbers.QNCompression}"><code>QuantumLattices.Interfaces.permute</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">permute(qns::AbelianNumbers, permutation::Vector{Int}, ::QNCompression) -&gt; AbelianNumbers
permute(qns::AbelianNumbers, permutation::Vector{Int}, ::QNExpansion) -&gt; AbelianNumbers</code></pre><p>Reorder the quantum numbers contained in an <code>AbelianNumbers</code> with a permutation and return the new one.</p><p>For <a href="#QuantumLattices.Mathematics.QuantumNumbers.qncompression"><code>qncompression</code></a> case, the permutation is for the compressed contents of the original <code>AbelianNumbers</code> while for <a href="#QuantumLattices.Mathematics.QuantumNumbers.qnexpansion"><code>qnexpansion</code></a> case, the permutation is for the expanded contents of the original <code>AbelianNumbers</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L425-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.regularize!-Union{Tuple{QN}, Tuple{Type{QN},AbstractArray{var&quot;#s19&quot;,1} where var&quot;#s19&quot;&lt;:Real}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#QuantumLattices.Interfaces.regularize!-Union{Tuple{QN}, Tuple{Type{QN},AbstractArray{var&quot;#s19&quot;,1} where var&quot;#s19&quot;&lt;:Real}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>QuantumLattices.Interfaces.regularize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regularize!(::Type{QN}, array::AbstractVector{&lt;:Real}) where QN&lt;:AbelianNumber -&gt; typeof(array)
regularize!(::Type{QN}, array::AbstractMatrix{&lt;:Real}) where QN&lt;:AbelianNumber -&gt; typeof(array)</code></pre><p>Regularize the elements of an array in place so that it can represent quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Interfaces.regularize-Union{Tuple{QN}, Tuple{Type{QN},Union{AbstractArray{var&quot;#s20&quot;,1} where var&quot;#s20&quot;&lt;:Real, AbstractArray{var&quot;#s19&quot;,2} where var&quot;#s19&quot;&lt;:Real}}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber" href="#QuantumLattices.Interfaces.regularize-Union{Tuple{QN}, Tuple{Type{QN},Union{AbstractArray{var&quot;#s20&quot;,1} where var&quot;#s20&quot;&lt;:Real, AbstractArray{var&quot;#s19&quot;,2} where var&quot;#s19&quot;&lt;:Real}}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber"><code>QuantumLattices.Interfaces.regularize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regularize(::Type{QN}, array::Union{AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}) where QN&lt;:AbelianNumber -&gt; typeof(array)</code></pre><p>Regularize the elements of an array and return a copy that can represent quantum numbers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.PQNS-Tuple{Real}" href="#QuantumLattices.Mathematics.QuantumNumbers.PQNS-Tuple{Real}"><code>QuantumLattices.Mathematics.QuantumNumbers.PQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PQNS(N::Real) -&gt; AbelianNumbers{PQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single-particle state with at most <code>N</code> identical particles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L744-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.SPQNS-Tuple{Real}" href="#QuantumLattices.Mathematics.QuantumNumbers.SPQNS-Tuple{Real}"><code>QuantumLattices.Mathematics.QuantumNumbers.SPQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SPQNS(S::Real) -&gt; AbelianNumbers{SPQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single site with internal degrees of freedom that can be ascribed to a spin <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L758-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.SQNS-Tuple{Real}" href="#QuantumLattices.Mathematics.QuantumNumbers.SQNS-Tuple{Real}"><code>QuantumLattices.Mathematics.QuantumNumbers.SQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SQNS(S::Real) -&gt; AbelianNumbers{SQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a signle spin <code>S</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L737-L741">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.SzPQNS-Tuple{Real}" href="#QuantumLattices.Mathematics.QuantumNumbers.SzPQNS-Tuple{Real}"><code>QuantumLattices.Mathematics.QuantumNumbers.SzPQNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SzPQNS(Sz::Real) -&gt; AbelianNumbers{SPQN}</code></pre><p>Construct the <code>AbelianNumbers</code> of the Hilbert space of a single-paritcle state with at most one particle whose spin-z component is <code>Sz</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L751-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.Z2QNS-Tuple{}" href="#QuantumLattices.Mathematics.QuantumNumbers.Z2QNS-Tuple{}"><code>QuantumLattices.Mathematics.QuantumNumbers.Z2QNS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Z2QNS() -&gt; AbelianNumbers{Z2QN}</code></pre><p>Construct the <code>AbelianNumbers</code> of a <span>$Z_2$</span> Hilbert space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L775-L779">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.toordereddict-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}" href="#QuantumLattices.Mathematics.QuantumNumbers.toordereddict-Tuple{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers,QuantumLattices.Mathematics.QuantumNumbers.QNIndptr}"><code>QuantumLattices.Mathematics.QuantumNumbers.toordereddict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">toordereddict(qns::AbelianNumbers, ::QNIndptr) -&gt; OrderedDict{qns|&gt;eltype, UnitRange{Int}}
toordereddict(qns::AbelianNumbers, ::QNCounts) -&gt; OrderedDict{qns|&gt;eltype, Int}</code></pre><p>Convert an <code>AbelianNumbers</code> to an ordered dict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L310-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Mathematics.QuantumNumbers.ukron-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},N}}, Tuple{QN}, Tuple{N}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber where N" href="#QuantumLattices.Mathematics.QuantumNumbers.ukron-Union{Tuple{Vararg{QuantumLattices.Mathematics.QuantumNumbers.AbelianNumbers{QN},N}}, Tuple{QN}, Tuple{N}} where QN&lt;:QuantumLattices.Mathematics.QuantumNumbers.AbelianNumber where N"><code>QuantumLattices.Mathematics.QuantumNumbers.ukron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ukron(qnses::Vararg{AbelianNumbers{QN}, N}; signs::NTuple{N, Int}=ntuple(i-&gt;1, N)) where {N, QN&lt;:AbelianNumber} -&gt; AbelianNumbers{QN}, Dict{QN, Dict{NTuple{N, QN}, UnitRange{Int}}}</code></pre><p>Unitary Kronecker product of several <code>AbelianNumbers</code>es. The product result as well as the records of the product will be returned.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>All input <code>AbelianNumbers</code> must be &#39;U&#39; formed or &#39;C&#39; formed.</li><li>Since duplicate quantum number are not allowed in &#39;U&#39; formed and &#39;C&#39; formed <code>AbelianNumbers</code>es, in general, there exists a merge process of duplicate quantum numbers in the product result. Therefore, records are needed to keep track of this process, which will be returned along with the product result. The records are stored in a <code>Dict{QN, Dict{NTuple{N, QN}, UnitRange{Int}}}</code> typed dict, in which, for each unduplicate quantum number <code>qn</code> in the product result, there exist a record <code>Dict((qn₁, qn₂, ...)=&gt;start:stop, ...)</code> telling what quantum numbers <code>(qn₁, qn₂, ...)</code> a mereged duplicate <code>qn</code> comes from and what slice <code>start:stop</code> this merged duplicate corresponds.</li></ol></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/e36328aedde056b3c8c598047021b666cb7606cd/src/Mathematics/QuantumNumbers.jl#L632-L639">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../AlgebraOverFields/">« Algebra over fields</a><a class="docs-footer-nextpage" href="../../Essentials/Introduction/">Introduction »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 September 2020 08:55">Wednesday 23 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
