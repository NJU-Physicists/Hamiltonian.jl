<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factories · QuantumLattices.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://quantum-many-body.github.io/QuantumLattices.jl/latest/man/Prerequisites/Factories/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="QuantumLattices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">QuantumLattices.jl</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Unitcell Description</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/SpatialInfoOfAUnitcell/">Spatial info of a unitcell</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/InternalDegreesOfFreedom/">Internal degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/CouplingsAmongDifferentDegreesOfFreedom/">Couplings among different degrees of freedom</a></li><li><a class="tocitem" href="../../../tutorials/UnitcellDescription/GeneratorOfOperators/">Generator of operators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Engine App Interface</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../tutorials/EngineAppInterface/Introduction/">Introduction</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Interfaces/">Interfaces</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox" checked/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Prerequisites</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../Introduction/">Introduction</a></li><li><a class="tocitem" href="../TypeTraits/">Type traits</a></li><li class="is-active"><a class="tocitem" href>Factories</a><ul class="internal"><li><a class="tocitem" href="#Escape-mechanisms"><span>Escape mechanisms</span></a></li><li><a class="tocitem" href="#Concrete-factories"><span>Concrete factories</span></a></li><li><a class="tocitem" href="#Manual"><span>Manual</span></a></li></ul></li><li><a class="tocitem" href="../CompositeStructures/">Composite structures</a></li><li><a class="tocitem" href="../SimpleTrees/">Simple trees</a></li><li><a class="tocitem" href="../NamedVectors/">Named vectors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Mathematics</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Mathematics/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../Mathematics/Combinatorics/">Combinatorics</a></li><li><a class="tocitem" href="../../Mathematics/VectorSpaces/">Vector spaces</a></li><li><a class="tocitem" href="../../Mathematics/AlgebraOverFields/">Algebra over fields</a></li><li><a class="tocitem" href="../../Mathematics/QuantumNumbers/">Quantum numbers</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Essentials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Essentials/Introduction/">Introduction</a></li><li><a class="tocitem" href="../../Essentials/Spatials/">Spatials</a></li><li><a class="tocitem" href="../../Essentials/DegreesOfFreedom/">Degrees of freedom</a></li><li><a class="tocitem" href="../../Essentials/Terms/">Terms</a></li><li><a class="tocitem" href="../../Essentials/FockPackage/">Fock package</a></li><li><a class="tocitem" href="../../Essentials/SpinPackage/">Spin package</a></li><li><a class="tocitem" href="../../Essentials/Frameworks/">Frameworks</a></li></ul></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../../developer/CodeStyle/">Code style guide</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">Prerequisites</a></li><li class="is-active"><a href>Factories</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Factories</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/master/docs/src/man/Prerequisites/Factories.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Factories"><a class="docs-heading-anchor" href="#Factories">Factories</a><a id="Factories-1"></a><a class="docs-heading-anchor-permalink" href="#Factories" title="Permalink"></a></h1><p>The aim of <code>Factories</code> is to provide tools to hack into Julia codes without knowing the details of their abstract syntax trees and regularize the mechanism to &quot;escape&quot; variables in <code>Expr</code> expressions, so that users can manipulate the existing codes, modify them and generate new ones in macros. In particular, a factory in this module means the representation of certain blocks of Julia codes by a usual Julia struct. This representation is much easier to comprehend than the canonical <code>Expr</code> representation and makes it far more convenient to define macros. In general, we propose the following requirements that any factory must satisfy:</p><ul><li><em>DECOMPOSITION</em> - An <code>Expr</code> expression can be decomposed into its corresponding factory by the factory&#39;s constructor.</li><li><em>COMPOSITION</em> - A factory can compose its corresponding <code>Expr</code> expression by calling itself.</li><li><em>ESCAPE</em> - A variable should be or not be escaped in the composed <code>Expr</code> expression by a factory depends on predefined escape mechanisms.</li></ul><p>These three requirements also define the basic interfaces to interact with factories. In practice, we combine the second and the third in a single interface, i.e. by passing an instance of certain concrete <a href="#QuantumLattices.Prerequisites.Factories.EscapeMechanism"><code>EscapeMechanism</code></a> as the only argument of calling a factory, the needed <code>Expr</code> expression with variables correctly escaped can be obtained.</p><h2 id="Escape-mechanisms"><a class="docs-heading-anchor" href="#Escape-mechanisms">Escape mechanisms</a><a id="Escape-mechanisms-1"></a><a class="docs-heading-anchor-permalink" href="#Escape-mechanisms" title="Permalink"></a></h2><p>We adopt Julia structs to denote escape mechanisms so that we can utilize Julia&#39;s multi-dispatch to implement different mechanisms whereas keeping the same interface.</p><h3 id="EscapeMechanism"><a class="docs-heading-anchor" href="#EscapeMechanism">EscapeMechanism</a><a id="EscapeMechanism-1"></a><a class="docs-heading-anchor-permalink" href="#EscapeMechanism" title="Permalink"></a></h3><p><a href="#QuantumLattices.Prerequisites.Factories.EscapeMechanism"><code>EscapeMechanism</code></a> is the abstract type for all concrete escape mechanisms.</p><h3 id="Escaped"><a class="docs-heading-anchor" href="#Escaped">Escaped</a><a id="Escaped-1"></a><a class="docs-heading-anchor-permalink" href="#Escaped" title="Permalink"></a></h3><p><a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a> has only one attribute:</p><ul><li><code>names::Tuple{Vararg{Symbol}}</code>: the names of variables to be escaped</li></ul><p>Apparently, a variable should be escaped if its name is in the <code>names</code> of an <code>Escaped</code>. This mechanism suits a factory whose variables should be unescaped by default.</p><h3 id="UnEscaped"><a class="docs-heading-anchor" href="#UnEscaped">UnEscaped</a><a id="UnEscaped-1"></a><a class="docs-heading-anchor-permalink" href="#UnEscaped" title="Permalink"></a></h3><p><a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> also has only on attribute:</p><ul><li><code>names::Tuple{Vararg{Symbol}}</code>: the names of variables not to be escaped</li></ul><p>Obviously, on the contrary to <a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a>, a variable should be escaped if its name is not in the <code>names</code> of an <code>UnEscaped</code>. This mechanism suits a factory whose variables should be escaped by default.</p><h3 id="MixEscaped"><a class="docs-heading-anchor" href="#MixEscaped">MixEscaped</a><a id="MixEscaped-1"></a><a class="docs-heading-anchor-permalink" href="#MixEscaped" title="Permalink"></a></h3><p><a href="#QuantumLattices.Prerequisites.Factories.MixEscaped"><code>MixEscaped</code></a> has two attributes:</p><ul><li><code>escaped::Escaped</code>: the escaped part of the mixed mechanism</li><li><code>unescaped::UnEscaped</code>: the UnEscaped part of the mixed mechanism</li></ul><p>This mechanism suits complex factories that parts of it suit the &quot;escaped&quot; mechanism while others suit the &quot;unescaped&quot; mechanism.</p><h3 id="RawExpr"><a class="docs-heading-anchor" href="#RawExpr">RawExpr</a><a id="RawExpr-1"></a><a class="docs-heading-anchor-permalink" href="#RawExpr" title="Permalink"></a></h3><p><a href="#QuantumLattices.Prerequisites.Factories.RawExpr"><code>RawExpr</code></a> has no attributes and it means &quot;raw expression without any variable escaped&quot;. This mechanism is used for the print of all factories by default.</p><h2 id="Concrete-factories"><a class="docs-heading-anchor" href="#Concrete-factories">Concrete factories</a><a id="Concrete-factories-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-factories" title="Permalink"></a></h2><p>Out of practical purposes, we implement 7 kinds of factories:</p><ul><li><strong><a href="#Inference">Inference</a></strong>: <strong>a type inference</strong>,</li><li><strong><a href="#Argument">Argument</a></strong>: <strong>a function argument</strong>,</li><li><strong><a href="#Parameter">Parameter</a></strong>: <strong>a method or type parameter</strong>,</li><li><strong><a href="#Field">Field</a></strong>: <strong>a struct field</strong>,</li><li><strong><a href="#Block">Block</a></strong>: <strong>a <code>begin ... end</code> block</strong>,</li><li><strong><a href="#FunctionFactory">FunctionFactory</a></strong>: <strong>a function itself</strong>,</li><li><strong><a href="#TypeFactory">TypeFactory</a></strong>: <strong>a struct itself</strong>.</li></ul><p>Some of the basic methods making the above three requirements fulfilled with these types are based on the powerful functions defined in <a href="https://github.com/MikeInnes/MacroTools.jl"><code>MacroTools</code></a>.</p><p>We want to give a remark that although the types and functions provided in this module helps a lot for the definition of macros, macros should not be abused. On the one hand, some macros may change the language specifications, which makes it hard to understand the codes, and even splits the community; on the one hand, macros usually increases the precompiling/jit time, which means enormous uses of macros in a module may lead to an extremely long load time. Besides, due to the limited ability of the author, the codes in this module are not optimal, which adds to the jit overhead. Any promotion that keeps the interfaces unchanged is welcomed on GitHub issues.</p><h3 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h3><p>An <a href="#QuantumLattices.Prerequisites.Factories.Inference"><code>Inference</code></a> has 3 attributes:</p><ul><li><code>head::Union{Symbol, Nothing}</code>: the head of the type inference, which must be one of <code>(nothing, :(&lt;:), :curly)</code></li><li><code>name::Union{Symbol, Nothing}</code>: the name of the type inference</li><li><code>params::Union{Inference, Vector{Inference}, Nothing}</code>: the parameters of the type inference</li></ul><p>All valid expressions representing type inferences can be passed to the constructor.</p><p>A type variable represented by a Symbol:</p><pre><code class="language-julia">Inference(:T)</code></pre><pre class="documenter-example-output">Inference(
  head:   nothing
  name:   T
  params: nothing
)</pre><p>A range of types represented by a UnionAll:</p><pre><code class="language-julia">Inference(:(&lt;:Number))</code></pre><pre class="documenter-example-output">Inference(
  head:   &lt;:
  name:   nothing
  params: Number
)</pre><p>A type with formal type parameters:</p><pre><code class="language-julia">Inference(:(Vector{T}))</code></pre><pre class="documenter-example-output">Inference(
  head:   curly
  name:   Vector
  params: Inference[T]
)</pre><p>A definite parametric type:</p><pre><code class="language-julia">Inference(:(Vector{Tuple{String, Int}}))</code></pre><pre class="documenter-example-output">Inference(
  head:   curly
  name:   Vector
  params: Inference[Tuple{String, Int}]
)</pre><p>A type with type parameters being UnionAlls:</p><pre><code class="language-julia">Inference(:(Type{&lt;:Number}))</code></pre><pre class="documenter-example-output">Inference(
  head:   curly
  name:   Type
  params: Inference[&lt;:Number]
)</pre><p>On the other hand, you can use the macro <a href="#QuantumLattices.Prerequisites.Factories.@inference-Tuple{Union{Expr, Symbol}}"><code>@inference</code></a> to construct an <code>Inference</code> directly from a type inference:</p><pre><code class="language-julia">@inference Vector{Tuple{String, Int}}</code></pre><pre class="documenter-example-output">Inference(
  head:   curly
  name:   Vector
  params: Inference[Tuple{String, Int}]
)</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li><code>Inference</code> is a recursive struct, i.e. it recursively decomposes a type inference until the final type inference is just a <code>Symbol</code>.</li><li>When the input expression is a <code>Symbol</code>, the <code>head</code> and <code>params</code> attributes of the resulting <code>Inference</code> is <code>nothing</code>. Otherwise, its <code>head</code> is the same with that of the input expression, and the <code>args</code> of the input expression will be further decomposed, whose result will be stored in <code>params</code>.</li><li>When the head of the input expression is <code>:(&lt;:)</code>, the <code>params</code> is an <code>Inference</code> whereas when the head of the input expression is <code>:curly</code>, the <code>params</code> is a <code>Vector{Inference}</code>.</li></ol></div></div><p><a href="#QuantumLattices.Prerequisites.Factories.Inference"><code>Inference</code></a> uses the <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> mechanism to escape variables, i.e. you have to specify the names that are not to be escaped.</p><p>Empty <code>UnEscaped()</code> escapes everything:</p><pre><code class="language-julia">Inference(:(Vector{T}))(UnEscaped())</code></pre><pre class="documenter-example-output">:(($(Expr(:escape, :Vector))){$(Expr(:escape, :T))})</pre><p>Unescape formal type parameters:</p><pre><code class="language-julia">Inference(:(Vector{T}))(UnEscaped(:T))</code></pre><pre class="documenter-example-output">:(($(Expr(:escape, :Vector))){T})</pre><p>Unescape both type names and type parameters:</p><pre><code class="language-julia">Inference(:(Vector{T}))(UnEscaped(:Vector, :T))</code></pre><pre class="documenter-example-output">:(Vector{T})</pre><h3 id="Argument"><a class="docs-heading-anchor" href="#Argument">Argument</a><a id="Argument-1"></a><a class="docs-heading-anchor-permalink" href="#Argument" title="Permalink"></a></h3><p>An <a href="#QuantumLattices.Prerequisites.Factories.Argument"><code>Argument</code></a> has 4 attributes:</p><ul><li><code>name::Union{Symbol, Nothing}</code>: the name of the argument</li><li><code>type::Inference</code>: the type inference of the argument</li><li><code>slurp::Bool</code>: whether the argument should be expanded by <code>...</code></li><li><code>default::Any</code>: the default value of the argument, <code>nothing</code> for those with no default values</li></ul><p>All valid expressions representing the arguments of functions can be passed to the constructor.</p><p>A formal argument represented by a Symbol:</p><pre><code class="language-julia">Argument(:arg)</code></pre><pre class="documenter-example-output">Argument(
  name:    arg
  type:    Any
  slurp:   false
  default: nothing
)</pre><p>A formal argument with its type specified:</p><pre><code class="language-julia">Argument(:(arg::ArgType))</code></pre><pre class="documenter-example-output">Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: nothing
)</pre><p>A slurped formal argument:</p><pre><code class="language-julia">Argument(:(arg::ArgType...))</code></pre><pre class="documenter-example-output">Argument(
  name:    arg
  type:    ArgType
  slurp:   true
  default: nothing
)</pre><p>A formal argument with a default value</p><pre><code class="language-julia">Argument(:(arg::ArgType=default))</code></pre><pre class="documenter-example-output">Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</pre><p>Or you can use the macro <a href="#QuantumLattices.Prerequisites.Factories.@argument-Tuple{Union{Expr, Symbol}}"><code>@argument</code></a> for a direct construction from an argument declaration:</p><pre><code class="language-julia">@argument arg::ArgType=default</code></pre><pre class="documenter-example-output">Argument(
  name:    arg
  type:    ArgType
  slurp:   false
  default: default
)</pre><p>The construction from such expressions is based on the <code>MacroTools.splitarg</code> function.</p><p><a href="#QuantumLattices.Prerequisites.Factories.Argument"><code>Argument</code></a> uses the <a href="#QuantumLattices.Prerequisites.Factories.MixEscaped"><code>MixEscaped</code></a> mechanism to escape variables, with the <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> mechanism for <code>type</code> and <a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a> mechanism for <code>default</code>, e.g.</p><pre><code class="language-julia">Argument(:(arg::Real=zero(Int)))(MixEscaped(UnEscaped(), Escaped(:zero, :Int)))</code></pre><pre class="documenter-example-output">:($(Expr(:kw, :(arg::$(Expr(:escape, :Real))), :(($(Expr(:escape, :zero)))($(Expr(:escape, :Int)))))))</pre><p>It can be seen that the name of an argument will never be escaped, which is obvious since the name of a function argument is always local. By the way, the composition of an <a href="#QuantumLattices.Prerequisites.Factories.Argument"><code>Argument</code></a> expression is based on the <code>MacroTools.combinearg</code> function.</p><h3 id="Parameter"><a class="docs-heading-anchor" href="#Parameter">Parameter</a><a id="Parameter-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter" title="Permalink"></a></h3><p>A <a href="#QuantumLattices.Prerequisites.Factories.Parameter"><code>Parameter</code></a> has 3 attributes:</p><ul><li><code>head::Union{Symbol, Nothing}</code>: the head of the parameter, must be either <code>:(&lt;:)</code> or <code>:(::)</code> if not <code>nothing</code></li><li><code>name::Union{Symbol, Nothing}</code>: the name of the parameter</li><li><code>type::Union{Inference, Nothing}</code>: the type inference of the parameter</li></ul><p>All expressions that represent type parameters or method parameters are allowed to be passed to the constructor.</p><p>A formal type/function parameter represented by a Symbol:</p><pre><code class="language-julia">Parameter(:T)</code></pre><pre class="documenter-example-output">Parameter(
  head: nothing
  name: T
  type: nothing
)</pre><p>A formal type/function parameter represented by a UnionAll with the name omitted:</p><pre><code class="language-julia">Parameter(:(&lt;:Number))</code></pre><pre class="documenter-example-output">Parameter(
  head: &lt;:
  name: nothing
  type: Number
)</pre><p>A formal type/function parameter represented by a UnionAll with the name specified:</p><pre><code class="language-julia">Parameter(:(T&lt;:Number))</code></pre><pre class="documenter-example-output">Parameter(
  head: &lt;:
  name: T
  type: Number
)</pre><p>The macro <a href="#QuantumLattices.Prerequisites.Factories.@parameter-Tuple{Union{Expr, Symbol}}"><code>@parameter</code></a> completes the construction directly from a parameter declaration:</p><pre><code class="language-julia">@parameter T&lt;:Number</code></pre><pre class="documenter-example-output">Parameter(
  head: &lt;:
  name: T
  type: Number
)</pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>We use <code>nothing</code> to denote a missing <code>name</code> or <code>type.</code></li><li>Two subtle situations of type/method parameters, e.g. <code>MyType{T}</code> and <code>MyType{Int}</code>, should be distinguished by <code>Parameter(:T)</code> and <code>Parameter(:(::Int))</code>.</li></ol></div></div><p><a href="#QuantumLattices.Prerequisites.Factories.Parameter"><code>Parameter</code></a> uses the <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> mechanism to escape variables, too, e.g.</p><pre><code class="language-julia">Parameter(:(N&lt;:Vector{T}))(UnEscaped(:T))</code></pre><pre class="documenter-example-output">:(N &lt;: ($(Expr(:escape, :Vector))){T})</pre><p>As is similar to <a href="#QuantumLattices.Prerequisites.Factories.Argument"><code>Argument</code></a>, the <code>name</code> of a method/type parameter will never be escaped because of its local scope.</p><h3 id="Field"><a class="docs-heading-anchor" href="#Field">Field</a><a id="Field-1"></a><a class="docs-heading-anchor-permalink" href="#Field" title="Permalink"></a></h3><p>A <a href="#QuantumLattices.Prerequisites.Factories.Field"><code>Field</code></a> has 2 attributes:</p><ul><li><code>name::Symbol</code>: the name of the field</li><li><code>type::Inference</code>: the type inference of the field</li></ul><p>Legal expressions can be used to construct a <code>Field</code> instance by its constructor.</p><p>A field name specified by a Symbol:</p><pre><code class="language-julia">Field(:field)</code></pre><pre class="documenter-example-output">Field(
  name: field
  type: Any
)</pre><p>A field with both the name and type specified:</p><pre><code class="language-julia">Field(:(field::FieldType))</code></pre><pre class="documenter-example-output">Field(
  name: field
  type: FieldType
)</pre><p>A field with the type being parametric:</p><pre><code class="language-julia">Field(:(field::ParametricType{T}))</code></pre><pre class="documenter-example-output">Field(
  name: field
  type: ParametricType{T}
)</pre><p>The macro <a href="#QuantumLattices.Prerequisites.Factories.@field-Tuple{Union{Expr, Symbol}}"><code>@field</code></a> is also provided to help the construction directly from a field declaration:</p><pre><code class="language-julia">@field field::FieldType</code></pre><pre class="documenter-example-output">Field(
  name: field
  type: FieldType
)</pre><p>The construction from these expressions is based on the <code>MacroTools.splitarg</code> function.</p><p><a href="#QuantumLattices.Prerequisites.Factories.Field"><code>Field</code></a> uses the <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> mechanism to escape variables as well, e.g.</p><pre><code class="language-julia">Field(:(field::Dict{N, D}))(UnEscaped(:N, :D))</code></pre><pre class="documenter-example-output">:(field::($(Expr(:escape, :Dict))){N, D})</pre><p>The name of a struct will never be escaped either because it is a local variable tightly binding to a struct. It is noted that the composition of field expressions is based on the <code>MacroTools.combinefield</code> function.</p><h3 id="Block"><a class="docs-heading-anchor" href="#Block">Block</a><a id="Block-1"></a><a class="docs-heading-anchor-permalink" href="#Block" title="Permalink"></a></h3><p>A <a href="#QuantumLattices.Prerequisites.Factories.Block"><code>Block</code></a> has only one attribute:</p><ul><li><code>body::Vector{Any}</code>: the body of the <code>begin ... end</code> block</li></ul><p>Any expression can be passed to the constructor of <code>Block</code>.</p><p>A single expression:</p><pre><code class="language-julia">Block(:(x = 1))</code></pre><pre class="documenter-example-output">Block(
  body: Any[:(x = 1)]
)</pre><p>A semicolon expression:</p><pre><code class="language-julia">Block(:(x = 1; y = 2))</code></pre><pre class="documenter-example-output">Block(
  body: Any[:(x = 1), :(#= none:1 =#), :(y = 2)]
)</pre><p>A <code>begin ... end</code> block:</p><pre><code class="language-julia">Block(:(begin x = 1 end))</code></pre><pre class="documenter-example-output">Block(
  body: Any[:(#= none:1 =#), :(x = 1)]
)</pre><p>A <code>quote</code> block:</p><pre><code class="language-julia">Block(quote
        x = 1
        y = 2
    end)</code></pre><pre class="documenter-example-output">Block(
  body: Any[:(#= none:2 =#), :(x = 1), :(#= none:3 =#), :(y = 2)]
)</pre><p>Or you can construct a <code>Block</code> instance directly from any code by the macro <a href="#QuantumLattices.Prerequisites.Factories.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>@block</code></a>:</p><pre><code class="language-julia">@block x=1 y=2</code></pre><pre class="documenter-example-output">Block(
  body: Any[:(x = 1), :(y = 2)]
)</pre><p>The body of a <code>block</code> can also be extended by the <a href="#Base.push!-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>push!</code></a> function or the <a href="#QuantumLattices.Prerequisites.Factories.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> macro.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>The body of a <code>Block</code> is somewhat &quot;flattened&quot;, i.e. it contains no <code>begin ... end</code> blocks. During the initialization, any such input block will be unblocked and added to the body part by part. So is the <a href="#Base.push!-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>push!</code></a> and <a href="#QuantumLattices.Prerequisites.Factories.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@push!</code></a> procedures.</li><li>All <code>LineNumberNode</code>s generated by the input codes will also be included in the block&#39;s body. However, you can use <a href="#QuantumLattices.Prerequisites.Factories.rmlines!-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>rmlines!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@rmlines!-Tuple{Expr}"><code>@rmlines!</code></a> to remove them from the body of an existing <code>Block</code>, or use <a href="#MacroTools.rmlines-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>rmlines</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@rmlines-Tuple{Expr}"><code>@rmlines</code></a> to get a copy with them removed in the body.</li></ol></div></div><p><a href="#QuantumLattices.Prerequisites.Factories.Block"><code>Block</code></a> uses the <a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a> mechanism to escape variables. This is because variables in a block are often local ones and should not be escaped. Therefore, only those defined in other modules should be noted and escaped, which usually constitute the minority. For example,</p><pre><code class="language-julia">Block(:(x = 1; y = 2; z = Int[1, 2, 3]))(Escaped(:Int))</code></pre><pre class="documenter-example-output">quote
    x = 1
    #= none:1 =#
    y = 2
    #= none:1 =#
    z = ($(Expr(:escape, :Int)))[1, 2, 3]
end</pre><h3 id="FunctionFactory"><a class="docs-heading-anchor" href="#FunctionFactory">FunctionFactory</a><a id="FunctionFactory-1"></a><a class="docs-heading-anchor-permalink" href="#FunctionFactory" title="Permalink"></a></h3><p>A <a href="#QuantumLattices.Prerequisites.Factories.FunctionFactory"><code>FunctionFactory</code></a> has 7 attributes:</p><ul><li><code>name::Union{Symbol, Expr}</code>: the name of the function</li><li><code>params::Vector{Inference}</code>: the method parameters of the function</li><li><code>args::Vector{Argument}</code>: the positional arguments of the function</li><li><code>kwargs::Vector{Argument}</code>: the keyword arguments of the function</li><li><code>rtype::Inference</code>: the return type of the function</li><li><code>whereparams::Vector{Parameter}</code>: the method parameters specified by the <code>where</code> keyword</li><li><code>body::Block</code>: the body of the function</li></ul><p>All expressions that represent functions are allowed to be passed to the constructor.</p><p>A function with no arguments:</p><pre><code class="language-julia">FunctionFactory(:(f() = nothing))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[]
  kwargs:      Argument[]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   #= none:1 =#
                   nothing
               end
)</pre><p>A function with arguments:</p><pre><code class="language-julia">FunctionFactory(:(f(x) = x))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::Any]
  kwargs:      Argument[]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   #= none:1 =#
                   x
               end
)</pre><p>A function with arguments that have default values:</p><pre><code class="language-julia">FunctionFactory(:(f(x::Int, y::Int; choice::Function=sum) = choice(x, y)))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::Int, y::Int]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       Any
  whereparams: Parameter[]
  body:        begin
                   #= none:1 =#
                   choice(x, y)
               end
)</pre><p>A function with arguments whose type are specified by <code>where</code> keyword:</p><pre><code class="language-julia">FunctionFactory(:(f(x::T, y::T; choice::Function=sum) where {T&lt;:Number} = choice(x, y)))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       Any
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:1 =#
                   choice(x, y)
               end
)</pre><p>A function with return type:</p><pre><code class="language-julia">FunctionFactory(:((f(x::T, y::T; choice::Function=sum)::T) where {T&lt;:Number} = choice(x, y)))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:1 =#
                   choice(x, y)
               end
)</pre><p>A multiline function:</p><pre><code class="language-julia">FunctionFactory(:(
    function (f(x::T, y::T; choice::Function=sum)::T) where T&lt;:Number
        choice(x, y)
    end
))</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:2 =#
                   #= none:3 =#
                   choice(x, y)
               end
)</pre><p>A function in a <code>quote</code> block:</p><pre><code class="language-julia">FunctionFactory(
    quote
        function (f(x::T, y::T; choice::Function=sum)::T) where T&lt;:Number
            choice(x, y)
        end
    end
)</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:3 =#
                   #= none:4 =#
                   choice(x, y)
               end
)</pre><p>Similarly, an instance can also be constructed from the macro <a href="#QuantumLattices.Prerequisites.Factories.@functionfactory-Tuple{Expr}"><code>@functionfactory</code></a>:</p><pre><code class="language-julia">@functionfactory (f(x::T, y::T; choice::Function=sum)::T) where {T&lt;:Number} = choice(x, y)</code></pre><pre class="documenter-example-output">FunctionFactory(
  name:        f
  params:      Inference[]
  args:        Argument[x::T, y::T]
  kwargs:      Argument[$(Expr(:kw, :(choice::Function), :sum))]
  rtype:       T
  whereparams: Parameter[T &lt;: Number]
  body:        begin
                   #= none:1 =#
                   choice(x, y)
               end
)</pre><p>The construction from such expressions are based on the <code>MacroTools.splitdef</code> function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><ol><li>Since Julia 0.7, the form <code>MyType{D}(data::D) where D</code> only appears in struct constructors, therefore, the attribute <code>:params</code> of a function factory is nonempty only when this factory aims to represent a struct constructor.</li><li>Usually, the name of a function factory is a <code>Symbol</code>. However, if the factory aims to extend some methods of a function defined in another module, e.g., <code>Base.eltype</code>, the name will be an <code>Expr</code>.</li></ol></div></div><p><a href="#QuantumLattices.Prerequisites.Factories.FunctionFactory"><code>FunctionFactory</code></a> adopts the <a href="#QuantumLattices.Prerequisites.Factories.MixEscaped"><code>MixEscaped</code></a> mechanism to escape variables, with <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> for <code>params</code>, <code>args</code>, <code>kwargs</code>, <code>rtype</code> and <code>whereparams</code> while <a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a> for <code>name</code> and <code>body</code>. It is worth to emphasize that the name of a function factory belongs to the <code>Escaped</code> part. Therefore, when it is an <code>Expr</code>, it will never be escaped because an <code>Expr</code> cannot be a element of a <code>Tuple{Vararg{Symbol}}</code>. See following examples.</p><p>Escape the function name:</p><pre><code class="language-julia">FunctionFactory(:(
    (f(x::T, y::T; choice::Function=sum)::T) where {T&lt;:Number} = max(x, y, choice(x, y))
    ))(MixEscaped(UnEscaped(:T), Escaped(:f, :max)))</code></pre><pre class="documenter-example-output">:(function (($(Expr(:escape, :f)))(x::T, y::T; choice::$(Expr(:escape, :Function)) = sum)::T) where T &lt;: $(Expr(:escape, :Number))
      #= none:2 =#
      ($(Expr(:escape, :max)))(x, y, choice(x, y))
  end)</pre><p>Do not escape the function name:</p><pre><code class="language-julia">FunctionFactory(:(
    (f(x::T, y::T; choice::Function=sum)::T) where {T&lt;:Number} = max(x, y, choice(x, y))
    ))(MixEscaped(UnEscaped(:T), Escaped(:max)))</code></pre><pre class="documenter-example-output">:(function (f(x::T, y::T; choice::$(Expr(:escape, :Function)) = sum)::T) where T &lt;: $(Expr(:escape, :Number))
      #= none:2 =#
      ($(Expr(:escape, :max)))(x, y, choice(x, y))
  end)</pre><p>The compositions of function expressions are based on the <code>MacroTools.combinedef</code> function.</p><p>Other features include:</p><ul><li>Positional arguments can be added by <a href="#QuantumLattices.Prerequisites.Factories.addargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>addargs!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addargs!</code></a></li><li>Keyword arguments can be added by <a href="#QuantumLattices.Prerequisites.Factories.addkwargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>addkwargs!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addkwargs!</code></a></li><li>Where parameters can be added by <a href="#QuantumLattices.Prerequisites.Factories.addwhereparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>addwhereparams!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addwhereparams!</code></a></li><li>Body can be extended by <a href="#QuantumLattices.Prerequisites.Factories.extendbody!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>extendbody!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@extendbody!</code></a></li></ul><h3 id="TypeFactory"><a class="docs-heading-anchor" href="#TypeFactory">TypeFactory</a><a id="TypeFactory-1"></a><a class="docs-heading-anchor-permalink" href="#TypeFactory" title="Permalink"></a></h3><p>A <a href="#QuantumLattices.Prerequisites.Factories.TypeFactory"><code>TypeFactory</code></a> has 6 attributes:</p><ul><li><code>name::Symbol</code>: the name of the struct</li><li><code>mutable::Bool</code>: whether or not the struct is mutable</li><li><code>params::Vector{Parameter}</code>: the type parameters of the struct</li><li><code>supertype::Inference</code>: the supertype of the struct</li><li><code>fields::Vector{Field}</code>: the fields of the struct</li><li><code>constructors::Vector{FunctionFactory}</code>: the inner constructors of the struct</li></ul><p>Any expression representing valid struct definitions can be passed to the constructor.</p><p>A struct with no fields:</p><pre><code class="language-julia">TypeFactory(:(struct StructName end))</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[]
  supertype:    Any
  fields:       Field[]
  constructors: FunctionFactory[]
)</pre><p>A parametric struct with no fields:</p><pre><code class="language-julia">TypeFactory(:(struct StructName{T} end))</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         StructName
  mutable:      false
  params:       Parameter[T]
  supertype:    Any
  fields:       Field[]
  constructors: FunctionFactory[]
)</pre><p>An empty struct with a supertype:</p><pre><code class="language-julia">TypeFactory(:(struct Child{T} &lt;: Parent{T} end))</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T]
  supertype:    Parent{T}
  fields:       Field[]
  constructors: FunctionFactory[]
)</pre><p>A fielded struct with a supertype</p><pre><code class="language-julia">TypeFactory(:(
    struct Child{T&lt;:Number} &lt;: Parent{T}
        field1::T
        field2::T
    end
))</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)</pre><p>A struct in a <code>quote</code> block:</p><pre><code class="language-julia">TypeFactory(
    quote
        struct Child{T&lt;:Number} &lt;: Parent{T}
            field1::T
            field2::T
        end
    end
)</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[]
)</pre><p>Also, the macro <a href="#QuantumLattices.Prerequisites.Factories.@typefactory-Tuple{Expr}"><code>@typefactory</code></a> supports the construction directly from a type definition:</p><pre><code class="language-julia">@typefactory struct Child{T&lt;:Number} &lt;: Parent{T}
                field1::T
                field2::T
                Child(field1::T, field2::T=zero(T)) where {T} = new{T}(field1, field2)
            end</code></pre><pre class="documenter-example-output">TypeFactory(
  name:         Child
  mutable:      false
  params:       Parameter[T &lt;: Number]
  supertype:    Parent{T}
  fields:       Field[field1::T, field2::T]
  constructors: FunctionFactory[
                  function (Child(field1::T, field2::T = zero(T); )::Any) where T
                      new{T}(field1, field2)
                  end
                  ]
)</pre><p>The construction from these expressions is based on the <code>MacroTools.splitstructdef</code> function.</p><p><a href="#QuantumLattices.Prerequisites.Factories.TypeFactory"><code>TypeFactory</code></a> also uses the <a href="#QuantumLattices.Prerequisites.Factories.MixEscaped"><code>MixEscaped</code></a> mechanism to escape variables, with the <a href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>UnEscaped</code></a> part for <code>params</code>, <code>supertype</code> and <code>fields</code>, the <a href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>Escaped</code></a> part for <code>name</code>, and both for <code>constructors</code>. For example,</p><pre><code class="language-julia">@typefactory(struct Child{T&lt;:Number} &lt;: Parent{T}
    field::T
    Child(field::T) where {T} = new{T}(field)
end)(MixEscaped(UnEscaped(:T), Escaped(:Child)))</code></pre><pre class="documenter-example-output">:(struct ($(Expr(:escape, :Child))){T &lt;: $(Expr(:escape, :Number))} &lt;: ($(Expr(:escape, :Parent))){T}
      #= /home/travis/.julia/packages/MacroTools/X77lQ/src/structdef.jl:57 =#
      field::T
      #= /home/travis/.julia/packages/MacroTools/X77lQ/src/structdef.jl:58 =#
      function (($(Expr(:escape, :Child)))(field::T; )::$(Expr(:escape, :Any))) where T
          new{T}(field)
      end
  end)</pre><p>The composition of a type expression is based on the <code>MacroTools.combinestructdef</code> function.</p><p>Other features include:</p><ul><li>Fields can be added by <a href="#QuantumLattices.Prerequisites.Factories.addfields!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}"><code>addfields!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addfields!</code></a></li><li>Type parameters can be added by <a href="#QuantumLattices.Prerequisites.Factories.addparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>addparams!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>@addparams!</code></a></li><li>Inner constructors can be added by <a href="#QuantumLattices.Prerequisites.Factories.addconstructors!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}"><code>addconstructors!</code></a> or <a href="#QuantumLattices.Prerequisites.Factories.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>@addconstructors!</code></a></li></ul><h2 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.FExpr" href="#QuantumLattices.Prerequisites.Factories.FExpr"><code>QuantumLattices.Prerequisites.Factories.FExpr</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Factory expression types, which is defined as <code>Union{Symbol, Expr}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.rawexpr" href="#QuantumLattices.Prerequisites.Factories.rawexpr"><code>QuantumLattices.Prerequisites.Factories.rawexpr</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">rawexpr</code></pre><p>Indicate that no variable in a factory should be escaped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.AbstractFactory" href="#QuantumLattices.Prerequisites.Factories.AbstractFactory"><code>QuantumLattices.Prerequisites.Factories.AbstractFactory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractFactory</code></pre><p>Abstract type for all concrete factories.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L125-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Argument" href="#QuantumLattices.Prerequisites.Factories.Argument"><code>QuantumLattices.Prerequisites.Factories.Argument</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Argument(name::Union{Symbol, Nothing}, type::Inference, slurp::Bool, default::Any)
Argument(; name::Union{Symbol, Nothing}=nothing, type::Inference=Inference(:Any), slurp::Bool=false, default::Any=nothing)
Argument(expr::FExpr)</code></pre><p>The struct to describe a argument of a <code>function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L248-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Argument-Tuple{QuantumLattices.Prerequisites.Factories.RawExpr}" href="#QuantumLattices.Prerequisites.Factories.Argument-Tuple{QuantumLattices.Prerequisites.Factories.RawExpr}"><code>QuantumLattices.Prerequisites.Factories.Argument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(a::Argument)(em::RawExpr) -&gt; Expr
(a::Argument)(em::MixEscaped) -&gt; Expr</code></pre><p>Convert an <code>Argument</code> to the <code>Expr</code> representation of the argument it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L274-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Block" href="#QuantumLattices.Prerequisites.Factories.Block"><code>QuantumLattices.Prerequisites.Factories.Block</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Block(parts::FExpr...)</code></pre><p>The struct to describe a <code>begin ... end</code> block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L368-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Block-Tuple{QuantumLattices.Prerequisites.Factories.MixEscaped}" href="#QuantumLattices.Prerequisites.Factories.Block-Tuple{QuantumLattices.Prerequisites.Factories.MixEscaped}"><code>QuantumLattices.Prerequisites.Factories.Block</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(b::Block)(em::RawExpr) -&gt; Expr
(b::Block)(em::Escaped) -&gt; Expr
(b::Block)(em::MixEscaped) -&gt; Expr</code></pre><p>Convert a <code>Block</code> to the <code>Expr</code> representation of the <code>begin ... end</code> block it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L387-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.EscapeMechanism" href="#QuantumLattices.Prerequisites.Factories.EscapeMechanism"><code>QuantumLattices.Prerequisites.Factories.EscapeMechanism</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract escape mechanism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Escaped" href="#QuantumLattices.Prerequisites.Factories.Escaped"><code>QuantumLattices.Prerequisites.Factories.Escaped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Escaped(names::Symbol...)</code></pre><p>Indicate that symbols of a factory should be escaped if they are in <code>names</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Field" href="#QuantumLattices.Prerequisites.Factories.Field"><code>QuantumLattices.Prerequisites.Factories.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Field(name::Symbol, type::Inference)
Field(; name::Symbol, type::FExpr=Inference(:Any))
Field(expr::FExpr)</code></pre><p>The struct to describe a field of a <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L335-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Field-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s20&quot;, var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped where var&quot;#s20&quot;&lt;:QuantumLattices.Prerequisites.Factories.UnEscaped}" href="#QuantumLattices.Prerequisites.Factories.Field-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s20&quot;, var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped where var&quot;#s20&quot;&lt;:QuantumLattices.Prerequisites.Factories.UnEscaped}"><code>QuantumLattices.Prerequisites.Factories.Field</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(f::Field)(em::RawExpr) -&gt; Expr
(f::Field)(em::UnEscaped) -&gt; Expr
(f::Field)(em::MixEscaped) -&gt; Expr</code></pre><p>Convert a <code>Field</code> to the <code>Expr</code> representation of the field it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L359-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.FunctionFactory" href="#QuantumLattices.Prerequisites.Factories.FunctionFactory"><code>QuantumLattices.Prerequisites.Factories.FunctionFactory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionFactory(name::FExpr,
                params::Vector{Inference},
                args::Vector{Argument},
                kwargs::Vector{Argument},
                rtype::Inference,
                whereparams::Vector{Parameter},
                body::Block
                )
FunctionFactory(;   name::FExpr,
                    params::Vector{Inference}=Inference[],
                    args::Vector{Argument}=Argument[],
                    kwargs::Vector{Argument}=Argument[],
                    rtype::Inference=Inference(:Any),
                    whereparams::Vector{Parameter}=Parameter[],
                    body::Block=Block()
                    )
FunctionFactory(expr::Expr)</code></pre><p>The struct to describe a <code>function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L453-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.FunctionFactory-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped}" href="#QuantumLattices.Prerequisites.Factories.FunctionFactory-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped}"><code>QuantumLattices.Prerequisites.Factories.FunctionFactory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(ff::FunctionFactory)(em::RawExpr) -&gt; Expr
(ff::FunctionFactory)(em::MixEscaped) -&gt; Expr</code></pre><p>Convert a <code>FunctionFactory</code> to the <code>Expr</code> representation of the <code>function</code> it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L515-L520">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Inference" href="#QuantumLattices.Prerequisites.Factories.Inference"><code>QuantumLattices.Prerequisites.Factories.Inference</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Inference(head::Union{Symbol, Nothing}, name::Union{Symbol, Nothing}, params::Union{Inference, Vector{Inference}, Nothing})
Inference(;
        head::Union{Symbol, Nothing}=nothing,
        name::Union{Symbol, Nothing}=nothing,
        params::Union{Inference, Vector{Inference}, Nothing}=nothing,
        )
Inference(expr::FExpr)</code></pre><p>The struct to describe a type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L184-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Inference-Tuple{QuantumLattices.Prerequisites.Factories.MixEscaped}" href="#QuantumLattices.Prerequisites.Factories.Inference-Tuple{QuantumLattices.Prerequisites.Factories.MixEscaped}"><code>QuantumLattices.Prerequisites.Factories.Inference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(i::Inference)(em::RawExpr) -&gt; FExpr
(i::Inference)(em::UnEscaped) -&gt; FExpr
(i::Inference)(em::MixEscaped) -&gt; FExpr</code></pre><p>Convert a <code>Inference</code> to the <code>Expr</code> representation of the type inference it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L230-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.MixEscaped" href="#QuantumLattices.Prerequisites.Factories.MixEscaped"><code>QuantumLattices.Prerequisites.Factories.MixEscaped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MixEscaped(escaped::Escaped)
MixEscaped(unescaped::UnEscaped)
MixEscaped(escaped::Escaped, unescaped::UnEscaped)
MixEscaped(unescaped::UnEscaped, escaped::Escaped)</code></pre><p>Indicate that some parts of a factory use the <code>Escaped</code> mechanism while other parts use the <code>UnEscaped</code> mechanism.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Parameter" href="#QuantumLattices.Prerequisites.Factories.Parameter"><code>QuantumLattices.Prerequisites.Factories.Parameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Parameter(head::Union{Symbol, Nothing}, name::Union{Symbol, Nothing}, type::Union{Inference, Nothing})
Parameter(; head::Union{Symbol, Nothing}=nothing, name::Union{Symbol, Nothing}=nothing, type::Union{Inference, Nothing}=nothing)
Parameter(expr::FExpr)</code></pre><p>The struct to describe a parameter of a <code>function</code> or a <code>type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L283-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.Parameter-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s20&quot;, var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped where var&quot;#s20&quot;&lt;:QuantumLattices.Prerequisites.Factories.UnEscaped}" href="#QuantumLattices.Prerequisites.Factories.Parameter-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s20&quot;, var&quot;#s19&quot;} where var&quot;#s19&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped where var&quot;#s20&quot;&lt;:QuantumLattices.Prerequisites.Factories.UnEscaped}"><code>QuantumLattices.Prerequisites.Factories.Parameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(p::Parameter)(em::RawExpr) -&gt; FExpr
(p::Parameter)(em::UnEscaped) -&gt; FExpr
(p::Parameter)(em::MixEscaped) -&gt; FExpr</code></pre><p>Convert a <code>Parameter</code> to the <code>Expr</code> representation of the parameter it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L322-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.RawExpr" href="#QuantumLattices.Prerequisites.Factories.RawExpr"><code>QuantumLattices.Prerequisites.Factories.RawExpr</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Raw expression without any variable escaped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.TypeFactory" href="#QuantumLattices.Prerequisites.Factories.TypeFactory"><code>QuantumLattices.Prerequisites.Factories.TypeFactory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TypeFactory(name::Symbol, mutable::Bool, params::Vector{Parameter}, supertype::Inference, fields::Vector{Field}, constructors::Vector{FunctionFactory})
TypeFactory(;   name::Symbol,
                mutable::Bool=false,
                params::Vector{Parameter}=Parameter[],
                supertype::Inference=Inference(:Any),
                fields::Vector{Field}=Field[],
                constructors::Vector{FunctionFactory}=FunctionFactory[]
                )
TypeFactory(expr::Expr)</code></pre><p>The struct to describe a <code>struct</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L610-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.TypeFactory-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped}" href="#QuantumLattices.Prerequisites.Factories.TypeFactory-Tuple{Union{QuantumLattices.Prerequisites.Factories.RawExpr, var&quot;#s21&quot;} where var&quot;#s21&quot;&lt;:QuantumLattices.Prerequisites.Factories.MixEscaped}"><code>QuantumLattices.Prerequisites.Factories.TypeFactory</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(tf::TypeFactory)(em::RawExpr) -&gt; Expr
(tf::TypeFactory)(em::MixEscaped) -&gt; Expr</code></pre><p>Convert a <code>TypeFactory</code> to the <code>Expr</code> representation of the <code>struct</code> it describes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L661-L666">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.UnEscaped" href="#QuantumLattices.Prerequisites.Factories.UnEscaped"><code>QuantumLattices.Prerequisites.Factories.UnEscaped</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UnEscaped(names::Symbol...)</code></pre><p>IIndicate that symbols of a factory should be escaped if they are not in <code>names</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addargs!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addargs! ff args::FExpr...</code></pre><p>Add a couple of positional arguments to a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L544-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addconstructors!-Tuple{Any,Vararg{Expr,N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addconstructors!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addconstructors! tf constructors::Expr...</code></pre><p>Add a couple of constructors to a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L708-L712">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addfields!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addfields!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addfields! tf fields::FExpr...</code></pre><p>Add a couple of fields to a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L689-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addkwargs!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addkwargs!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addkwargs! ff kwargs::FExpr...</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L563-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addparams!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addparams! f params::FExpr...</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L733-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@addwhereparams!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@addwhereparams!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@addwhereparams! ff whereparams::FExpr...</code></pre><p>Add a couple of method parameters to a function factory or a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L601-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@argument-Tuple{Union{Expr, Symbol}}" href="#QuantumLattices.Prerequisites.Factories.@argument-Tuple{Union{Expr, Symbol}}"><code>QuantumLattices.Prerequisites.Factories.@argument</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@argument expr::FExpr</code></pre><p>Construct an <code>Argument</code> directly from an argument statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@block-Tuple{Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@block</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@block parts::FExpr...</code></pre><p>Construct a <code>Block</code> directly from a <code>begin ... end</code> block definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@extendbody!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@extendbody!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@extendbody! ff parts::FExpr...</code></pre><p>Extend the body of a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L582-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@field-Tuple{Union{Expr, Symbol}}" href="#QuantumLattices.Prerequisites.Factories.@field-Tuple{Union{Expr, Symbol}}"><code>QuantumLattices.Prerequisites.Factories.@field</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@field expr::FExpr</code></pre><p>Construct a <code>Field</code> directly from a field statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L349-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@functionfactory-Tuple{Expr}" href="#QuantumLattices.Prerequisites.Factories.@functionfactory-Tuple{Expr}"><code>QuantumLattices.Prerequisites.Factories.@functionfactory</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@functionfactory expr::FExpr</code></pre><p>Construct a <code>FunctionFactory</code> directly from a function definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L505-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@inference-Tuple{Union{Expr, Symbol}}" href="#QuantumLattices.Prerequisites.Factories.@inference-Tuple{Union{Expr, Symbol}}"><code>QuantumLattices.Prerequisites.Factories.@inference</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@inference expr::FExpr</code></pre><p>Construct an <code>Inference</code> directly from a type inference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@parameter-Tuple{Union{Expr, Symbol}}" href="#QuantumLattices.Prerequisites.Factories.@parameter-Tuple{Union{Expr, Symbol}}"><code>QuantumLattices.Prerequisites.Factories.@parameter</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@parameter expr::FExpr</code></pre><p>Construct a <code>Parameter</code> directly from an parameter statement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L312-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}" href="#QuantumLattices.Prerequisites.Factories.@push!-Tuple{Any,Vararg{Union{Expr, Symbol},N} where N}"><code>QuantumLattices.Prerequisites.Factories.@push!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@push! b parts::FExpr...</code></pre><p>Push other parts into the body of a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L412-L416">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@rmlines!-Tuple{Expr}" href="#QuantumLattices.Prerequisites.Factories.@rmlines!-Tuple{Expr}"><code>QuantumLattices.Prerequisites.Factories.@rmlines!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@rmlines! b::Expr</code></pre><p>Remove line number nodes in the body of a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L428-L432">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@rmlines-Tuple{Expr}" href="#QuantumLattices.Prerequisites.Factories.@rmlines-Tuple{Expr}"><code>QuantumLattices.Prerequisites.Factories.@rmlines</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@rmlines b::Expr</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L444-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.@typefactory-Tuple{Expr}" href="#QuantumLattices.Prerequisites.Factories.@typefactory-Tuple{Expr}"><code>QuantumLattices.Prerequisites.Factories.@typefactory</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@typefactory expr::Expr</code></pre><p>Construct a <code>TypeFactory</code> directly from a type definition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L651-L655">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:QuantumLattices.Prerequisites.Factories.AbstractFactory" href="#Base.:==-Union{Tuple{F}, Tuple{F,F}} where F&lt;:QuantumLattices.Prerequisites.Factories.AbstractFactory"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(f1::F, f2::F) where F&lt;:AbstractFactory -&gt; Bool</code></pre><p>Overloaded equivalent operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isequal-Union{Tuple{F}, Tuple{F,F}} where F&lt;:QuantumLattices.Prerequisites.Factories.AbstractFactory" href="#Base.isequal-Union{Tuple{F}, Tuple{F,F}} where F&lt;:QuantumLattices.Prerequisites.Factories.AbstractFactory"><code>Base.isequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isequal(f1::F, f2::F) where F&lt;:AbstractFactory -&gt; Bool</code></pre><p>Overloaded equivalent operator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.names-Tuple{Symbol}" href="#Base.names-Tuple{Symbol}"><code>Base.names</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">names(expr::Symbol) -&gt; Vector{Symbol}
names(expr::Expr) -&gt; Vector{Symbol}</code></pre><p>Get all the symbols in an expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.push!-Tuple{QuantumLattices.Prerequisites.Factories.Block}" href="#Base.push!-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push!(b::Block, parts::FExpr...) -&gt; Block
push!(b::Block, parts::Block...) -&gt; Block</code></pre><p>Push other parts into the body of a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L397-L402">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.replace-Tuple{QuantumLattices.Prerequisites.Factories.AbstractFactory}" href="#Base.replace-Tuple{QuantumLattices.Prerequisites.Factories.AbstractFactory}"><code>Base.replace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace(f::AbstractFactory; kwargs...) -&gt; typeof(f)</code></pre><p>Return a copy of a concrete <code>AbstractFactory</code> with some of the field values replaced by the keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.show-Tuple{IO,QuantumLattices.Prerequisites.Factories.AbstractFactory}" href="#Base.show-Tuple{IO,QuantumLattices.Prerequisites.Factories.AbstractFactory}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">show(io::IO, f::AbstractFactory)</code></pre><p>Show a concrete <code>AbstractFactory</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MacroTools.rmlines-Tuple{QuantumLattices.Prerequisites.Factories.Block}" href="#MacroTools.rmlines-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>MacroTools.rmlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmlines(b::Block) -&gt; Block</code></pre><p>Return a copy of a block with the line number nodes removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L437-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}" href="#QuantumLattices.Prerequisites.Factories.addargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>QuantumLattices.Prerequisites.Factories.addargs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addargs!(ff::FunctionFactory, args::Argument...) -&gt; FunctionFactory
addargs!(ff::FunctionFactory, args::FExpr...) -&gt; FunctionFactory</code></pre><p>Add a couple of positional arguments to a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L534-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addconstructors!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}" href="#QuantumLattices.Prerequisites.Factories.addconstructors!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}"><code>QuantumLattices.Prerequisites.Factories.addconstructors!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addconstructors!(tf::TypeFactory, constructors::FunctionFactory...) -&gt; TypeFactory
addconstructors!(tf::TypeFactory, constructors::Expr...) -&gt; TypeFactory</code></pre><p>Add a couple of constructors to a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L698-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addfields!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}" href="#QuantumLattices.Prerequisites.Factories.addfields!-Tuple{QuantumLattices.Prerequisites.Factories.TypeFactory}"><code>QuantumLattices.Prerequisites.Factories.addfields!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addfields!(tf::TypeFactory, fields::Field...) -&gt; TypeFactory
addfields!(tf::TypeFactory, fields::FExpr...) -&gt; TypeFactory</code></pre><p>Add a couple of fields to a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L679-L684">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addkwargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}" href="#QuantumLattices.Prerequisites.Factories.addkwargs!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>QuantumLattices.Prerequisites.Factories.addkwargs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addkwargs!(ff::FunctionFactory, kwargs::Argument...) -&gt; FunctionFactory
addkwargs!(ff::FunctionFactory, kwargs::FExpr...) -&gt; FunctionFactory</code></pre><p>Add a couple of keyword arguments to a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}" href="#QuantumLattices.Prerequisites.Factories.addparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>QuantumLattices.Prerequisites.Factories.addparams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addparams!(f::FunctionFactory, params::Inference...) -&gt;FunctionFactory
addparams!(f::FunctionFactory, params::FExpr...) -&gt; FunctionFactory
addparams!(f::TypeFactory, params::Parameter...) -&gt; TypeFactory
addparams!(f::TypeFactory, params::FExpr...) -&gt; TypeFactory</code></pre><p>Add a couple of parameters to a function factory or a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L717-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.addwhereparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}" href="#QuantumLattices.Prerequisites.Factories.addwhereparams!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>QuantumLattices.Prerequisites.Factories.addwhereparams!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addwhereparams!(ff::FunctionFactory, whereparams::Parameter...) -&gt; FunctionFactory
addwhereparams!(ff::FunctionFactory, whereparams::FExpr...) -&gt; FunctionFactory</code></pre><p>Add a couple of method where parameters to a function factory or a type factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L591-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.escape-Tuple{Any,QuantumLattices.Prerequisites.Factories.RawExpr}" href="#QuantumLattices.Prerequisites.Factories.escape-Tuple{Any,QuantumLattices.Prerequisites.Factories.RawExpr}"><code>QuantumLattices.Prerequisites.Factories.escape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">escape(expr, ::RawExpr) -&gt; Any
escape(expr, ::Escaped) -&gt; Any
escape(expr, ::UnEscaped) -&gt; Any
escape(expr::Symbol, em::Escaped) -&gt; FExpr
escape(expr::Expr, em::Escaped) -&gt; Expr
escape(expr::Symbol, em::UnEscaped) -&gt; FExpr
escape(expr::Expr, em::UnEscaped) -&gt; Expr</code></pre><p>Escape the variables in the input expression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.extendbody!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}" href="#QuantumLattices.Prerequisites.Factories.extendbody!-Tuple{QuantumLattices.Prerequisites.Factories.FunctionFactory}"><code>QuantumLattices.Prerequisites.Factories.extendbody!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">extendbody!(ff::FunctionFactory, parts::FExpr...) -&gt; FunctionFactory
extendbody!(ff::FunctionFactory, parts::Block...) -&gt; FunctionFactory</code></pre><p>Extend the body of a function factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L572-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuantumLattices.Prerequisites.Factories.rmlines!-Tuple{QuantumLattices.Prerequisites.Factories.Block}" href="#QuantumLattices.Prerequisites.Factories.rmlines!-Tuple{QuantumLattices.Prerequisites.Factories.Block}"><code>QuantumLattices.Prerequisites.Factories.rmlines!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmlines!(b::Block) -&gt; Block</code></pre><p>Remove line number nodes in the body of a block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Quantum-Many-Body/QuantumLattices.jl/blob/6bdf2ce61fc241f283fd1610ea41c26462651b81/src/Prerequisites/Factories.jl#L421-L425">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../TypeTraits/">« Type traits</a><a class="docs-footer-nextpage" href="../CompositeStructures/">Composite structures »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 24 September 2020 09:52">Thursday 24 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
